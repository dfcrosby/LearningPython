# Notes

PS K:\github\learningpython> python -m pydoc raw_input
Help on built-in function raw_input in module __builtin__:

raw_input(...)
    raw_input([prompt]) -> string

    Read a string from standard input.  The trailing newline is stripped.
    If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.
    On Unix, GNU readline is used if enabled.  The prompt string, if given,
    is printed without a trailing newline before reading.
	
PS K:\github\learningpython> python -m pydoc open
Help on built-in function open in module __builtin__:

open(...)
    open(name[, mode[, buffering]]) -> file object

    Open a file using the file() type, returns a file object.  This is the
    preferred way to open a file.  See file.__doc__ for further information.

PS K:\github\learningpython> python -m pydoc file
Help on class file in module __builtin__:

class file(object)
 |  file(name[, mode[, buffering]]) -> file object
 |
 |  Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),
 |  writing or appending.  The file will be created if it doesn't exist
 |  when opened for writing or appending; it will be truncated when
 |  opened for writing.  Add a 'b' to the mode for binary files.
 |  Add a '+' to the mode to allow simultaneous reading and writing.
 |  If the buffering argument is given, 0 means unbuffered, 1 means line
 |  buffered, and larger numbers specify the buffer size.  The preferred way
 |  to open a file is with the builtin open() function.
 |  Add a 'U' to mode to open the file for input with universal newline
 |  support.  Any line ending in the input file will be seen as a '\n'
 |  in Python.  Also, a file so opened gains the attribute 'newlines';
 |  the value for this attribute is one of None (no newline read yet),
 |  '\r', '\n', '\r\n' or a tuple containing all the newline types seen.
 |
 |  'U' cannot be combined with 'w' or '+' mode.
 |
 |  Methods defined here:
 |
 |  __delattr__(...)
 |      x.__delattr__('name') <==> del x.name
 |
 |  __enter__(...)
 |      __enter__() -> self.
 |
 |  __exit__(...)
 |      __exit__(*excinfo) -> None.  Closes the file.
 |
 |  __getattribute__(...)
 |      x.__getattribute__('name') <==> x.name
 |
 |  __init__(...)
 |      x.__init__(...) initializes x; see help(type(x)) for signature
 |
 |  __iter__(...)
 |      x.__iter__() <==> iter(x)
 |
 |  __repr__(...)
 |      x.__repr__() <==> repr(x)
 |
 |  __setattr__(...)
 |      x.__setattr__('name', value) <==> x.name = value
 |
 |  close(...)
 |      close() -> None or (perhaps) an integer.  Close the file.
 |
 |      Sets data attribute .closed to True.  A closed file cannot be used for
 |      further I/O operations.  close() may be called more than once without
 |      error.  Some kinds of file objects (for example, opened by popen())
 |      may return an exit status upon closing.
 |
 |  fileno(...)
 |      fileno() -> integer "file descriptor".
 |
 |      This is needed for lower-level file interfaces, such os.read().
 |
 |  flush(...)
 |      flush() -> None.  Flush the internal I/O buffer.
 |
 |  isatty(...)
 |      isatty() -> true or false.  True if the file is connected to a tty device.
 |
 |  next(...)
 |      x.next() -> the next value, or raise StopIteration
 |
 |  read(...)
 |      read([size]) -> read at most size bytes, returned as a string.
 |
 |      If the size argument is negative or omitted, read until EOF is reached.
 |      Notice that when in non-blocking mode, less data than what was requested
 |      may be returned, even if no size parameter was given.
 |
 |  readinto(...)
 |      readinto() -> Undocumented.  Don't use this; it may go away.
 |
 |  readline(...)
 |      readline([size]) -> next line from the file, as a string.
 |
 |      Retain newline.  A non-negative size argument limits the maximum
 |      number of bytes to return (an incomplete line may be returned then).
 |      Return an empty string at EOF.
 |
 |  readlines(...)
 |      readlines([size]) -> list of strings, each a line from the file.
 |
 |      Call readline() repeatedly and return a list of the lines so read.
 |      The optional size argument, if given, is an approximate bound on the
 |      total number of bytes in the lines returned.
 |
 |  seek(...)
 |      seek(offset[, whence]) -> None.  Move to new file position.
 |
 |      Argument offset is a byte count.  Optional argument whence defaults to
 |      0 (offset from start of file, offset should be >= 0); other values are 1
 |      (move relative to current position, positive or negative), and 2 (move
 |      relative to end of file, usually negative, although many platforms allow
 |      seeking beyond the end of a file).  If the file is opened in text mode,
 |      only offsets returned by tell() are legal.  Use of other offsets causes
 |      undefined behavior.
 |      Note that not all file objects are seekable.
 |
 |  tell(...)
 |      tell() -> current file position, an integer (may be a long integer).
 |
 |  truncate(...)
 |      truncate([size]) -> None.  Truncate the file to at most size bytes.
 |
 |      Size defaults to the current file position, as returned by tell().
 |
 |  write(...)
 |      write(str) -> None.  Write string str to file.
 |
 |      Note that due to buffering, flush() or close() may be needed before
 |      the file on disk reflects the data written.
 |
 |  writelines(...)
 |      writelines(sequence_of_strings) -> None.  Write the strings to the file.
 |
 |      Note that newlines are not added.  The sequence can be any iterable object
 |      producing strings. This is equivalent to calling write() for each string.
 |
 |  xreadlines(...)
 |      xreadlines() -> returns self.
 |
 |      For backward compatibility. File objects now include the performance
 |      optimizations previously implemented in the xreadlines module.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  closed
 |      True if the file is closed
 |
 |  encoding
 |      file encoding
 |
 |  errors
 |      Unicode error handler
 |
 |  mode
 |      file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)
 |
 |  name
 |      file name
 |
 |  newlines
 |      end-of-line convention used in this file
 |
 |  softspace
 |      flag indicating that a space needs to be printed; used by print
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  __new__ = <built-in method __new__ of type object>
 |      T.__new__(S, ...) -> a new object with type S, a subtype of T

 
PS K:\github\learningpython> python -m pydoc os
Help on module os:

NAME
    os - OS routines for NT or Posix depending on what system we're on.

FILE
    c:\python27\lib\os.py

DESCRIPTION
    This exports:
      - all functions from posix, nt, os2, or ce, e.g. unlink, stat, etc.
      - os.path is one of the modules posixpath, or ntpath
      - os.name is 'posix', 'nt', 'os2', 'ce' or 'riscos'
      - os.curdir is a string representing the current directory ('.' or ':')
      - os.pardir is a string representing the parent directory ('..' or '::')
      - os.sep is the (or a most common) pathname separator ('/' or ':' or '\\')
      - os.extsep is the extension separator ('.' or '/')
      - os.altsep is the alternate pathname separator (None or '/')
      - os.pathsep is the component separator used in $PATH etc
      - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
      - os.defpath is the default search path for executables
      - os.devnull is the file path of the null device ('/dev/null', etc.)

    Programs that import and use 'os' stand a better chance of being
    portable between different platforms.  Of course, they must then
    only use functions that are defined by all platforms (e.g., unlink
    and opendir), and leave all pathname manipulation to os.path
    (e.g., split and join).

CLASSES
    __builtin__.object
        nt.stat_result
        nt.statvfs_result
    exceptions.EnvironmentError(exceptions.StandardError)
        exceptions.OSError

    error = class OSError(EnvironmentError)
     |  OS system call failed.
     |
     |  Method resolution order:
     |      OSError
     |      EnvironmentError
     |      StandardError
     |      Exception
     |      BaseException
     |      __builtin__.object
     |
     |  Methods defined here:
     |
     |  __init__(...)
     |      x.__init__(...) initializes x; see help(type(x)) for signature
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from EnvironmentError:
     |
     |  __reduce__(...)
     |
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from EnvironmentError:
     |
     |  errno
     |      exception errno
     |
     |  filename
     |      exception filename
     |
     |  strerror
     |      exception strerror
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from BaseException:
     |
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |
     |      Use of negative indices is not supported.
     |
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |
     |  __setstate__(...)
     |
     |  __unicode__(...)
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from BaseException:
     |
     |  __dict__
     |
     |  args
     |
     |  message

    class stat_result(__builtin__.object)
     |  stat_result: Result from stat or lstat.
     |
     |  This object may be accessed either as a tuple of
     |    (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)
     |  or via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.
     |
     |  Posix/windows: If your platform supports st_blksize, st_blocks, st_rdev,
     |  or st_flags, they are available as attributes only.
     |
     |  See os.stat for more information.
     |
     |  Methods defined here:
     |
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |
     |      Use of negative indices is not supported.
     |
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |
     |  __reduce__(...)
     |
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  st_atime
     |      time of last access
     |
     |  st_ctime
     |      time of last change
     |
     |  st_dev
     |      device
     |
     |  st_gid
     |      group ID of owner
     |
     |  st_ino
     |      inode
     |
     |  st_mode
     |      protection bits
     |
     |  st_mtime
     |      time of last modification
     |
     |  st_nlink
     |      number of hard links
     |
     |  st_size
     |      total size, in bytes
     |
     |  st_uid
     |      user ID of owner
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |
     |  n_fields = 13
     |
     |  n_sequence_fields = 10
     |
     |  n_unnamed_fields = 3

    class statvfs_result(__builtin__.object)
     |  statvfs_result: Result from statvfs or fstatvfs.
     |
     |  This object may be accessed either as a tuple of
     |    (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),
     |  or via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.
     |
     |  See os.statvfs for more information.
     |
     |  Methods defined here:
     |
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |
     |      Use of negative indices is not supported.
     |
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |
     |  __hash__(...)
     |      x.__hash__() <==> hash(x)
     |
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |
     |  __reduce__(...)
     |
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  f_bavail
     |
     |  f_bfree
     |
     |  f_blocks
     |
     |  f_bsize
     |
     |  f_favail
     |
     |  f_ffree
     |
     |  f_files
     |
     |  f_flag
     |
     |  f_frsize
     |
     |  f_namemax
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |
     |  n_fields = 10
     |
     |  n_sequence_fields = 10
     |
     |  n_unnamed_fields = 0

FUNCTIONS
    abort(...)
        abort() -> does not return!

        Abort the interpreter immediately.  This 'dumps core' or otherwise fails
        in the hardest way possible on the hosting operating system.

    access(...)
        access(path, mode) -> True if granted, False otherwise

        Use the real uid/gid to test for access to a path.  Note that most
        operations will use the effective uid/gid, therefore this routine can
        be used in a suid/sgid environment to test if the invoking user has the
        specified access to the path.  The mode argument can be F_OK to test
        existence, or the inclusive-OR of R_OK, W_OK, and X_OK.

    chdir(...)
        chdir(path)

        Change the current working directory to the specified path.

    chmod(...)
        chmod(path, mode)

        Change the access permissions of a file.

    close(...)
        close(fd)

        Close a file descriptor (for low level IO).

    closerange(...)
        closerange(fd_low, fd_high)

        Closes all file descriptors in [fd_low, fd_high), ignoring errors.

    dup(...)
        dup(fd) -> fd2

        Return a duplicate of a file descriptor.

    dup2(...)
        dup2(old_fd, new_fd)

        Duplicate file descriptor.

    execl(file, *args)
        execl(file, *args)

        Execute the executable file with argument list args, replacing the
        current process.

    execle(file, *args)
        execle(file, *args, env)

        Execute the executable file with argument list args and
        environment env, replacing the current process.

    execlp(file, *args)
        execlp(file, *args)

        Execute the executable file (which is searched for along $PATH)
        with argument list args, replacing the current process.

    execlpe(file, *args)
        execlpe(file, *args, env)

        Execute the executable file (which is searched for along $PATH)
        with argument list args and environment env, replacing the current
        process.

    execv(...)
        execv(path, args)

        Execute an executable path with arguments, replacing current process.

            path: path of executable file
            args: tuple or list of strings

    execve(...)
        execve(path, args, env)

        Execute a path with arguments and environment, replacing current process.

            path: path of executable file
            args: tuple or list of arguments
            env: dictionary of strings mapping to strings

    execvp(file, args)
        execvp(file, args)

        Execute the executable file (which is searched for along $PATH)
        with argument list args, replacing the current process.
        args may be a list or tuple of strings.

    execvpe(file, args, env)
        execvpe(file, args, env)

        Execute the executable file (which is searched for along $PATH)
        with argument list args and environment env , replacing the
        current process.
        args may be a list or tuple of strings.

    fdopen(...)
        fdopen(fd [, mode='r' [, bufsize]]) -> file_object

        Return an open file object connected to a file descriptor.

    fstat(...)
        fstat(fd) -> stat result

        Like stat(), but for an open file descriptor.

    fsync(...)
        fsync(fildes)

        force write of file with filedescriptor to disk.

    getcwd(...)
        getcwd() -> path

        Return a string representing the current working directory.

    getcwdu(...)
        getcwdu() -> path

        Return a unicode string representing the current working directory.

    getenv(key, default=None)
        Get an environment variable, return None if it doesn't exist.
        The optional second argument can specify an alternate default.

    getpid(...)
        getpid() -> pid

        Return the current process id

    isatty(...)
        isatty(fd) -> bool

        Return True if the file descriptor 'fd' is an open file descriptor
        connected to the slave end of a terminal.

    kill(...)
        kill(pid, sig)

        Kill a process with a signal.

    listdir(...)
        listdir(path) -> list_of_strings

        Return a list containing the names of the entries in the directory.

            path: path of directory to list

        The list is in arbitrary order.  It does not include the special
        entries '.' and '..' even if they are present in the directory.

    lseek(...)
        lseek(fd, pos, how) -> newpos

        Set the current position of a file descriptor.
        Return the new cursor position in bytes, starting from the beginning.

    lstat(...)
        lstat(path) -> stat result

        Like stat(path), but do not follow symbolic links.

    makedirs(name, mode=511)
        makedirs(path [, mode=0777])

        Super-mkdir; create a leaf directory and all intermediate ones.
        Works like mkdir, except that any intermediate path segment (not
        just the rightmost) will be created if it does not exist.  This is
        recursive.

    mkdir(...)
        mkdir(path [, mode=0777])

        Create a directory.

    open(...)
        open(filename, flag [, mode=0777]) -> fd

        Open a file (for low level IO).

    pipe(...)
        pipe() -> (read_end, write_end)

        Create a pipe.

    popen(...)
        popen(command [, mode='r' [, bufsize]]) -> pipe

        Open a pipe to/from a command returning a file object.

    popen2(...)

    popen3(...)

    popen4(...)

    putenv(...)
        putenv(key, value)

        Change or add an environment variable.

    read(...)
        read(fd, buffersize) -> string

        Read a file descriptor.

    remove(...)
        remove(path)

        Remove a file (same as unlink(path)).

    removedirs(name)
        removedirs(path)

        Super-rmdir; remove a leaf directory and all empty intermediate
        ones.  Works like rmdir except that, if the leaf directory is
        successfully removed, directories corresponding to rightmost path
        segments will be pruned away until either the whole path is
        consumed or an error occurs.  Errors during this latter phase are
        ignored -- they generally mean that a directory was not empty.

    rename(...)
        rename(old, new)

        Rename a file or directory.

    renames(old, new)
        renames(old, new)

        Super-rename; create directories as necessary and delete any left
        empty.  Works like rename, except creation of any intermediate
        directories needed to make the new pathname good is attempted
        first.  After the rename, directories corresponding to rightmost
        path segments of the old name will be pruned way until either the
        whole path is consumed or a nonempty directory is found.

        Note: this function can fail with the new directory structure made
        if you lack permissions needed to unlink the leaf directory or
        file.

    rmdir(...)
        rmdir(path)

        Remove a directory.

    spawnl(mode, file, *args)
        spawnl(mode, file, *args) -> integer

        Execute file with arguments from args in a subprocess.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.

    spawnle(mode, file, *args)
        spawnle(mode, file, *args, env) -> integer

        Execute file with arguments from args in a subprocess with the
        supplied environment.
        If mode == P_NOWAIT return the pid of the process.
        If mode == P_WAIT return the process's exit code if it exits normally;
        otherwise return -SIG, where SIG is the signal that killed it.

    spawnv(...)
        spawnv(mode, path, args)

        Execute the program 'path' in a new process.

            mode: mode of process creation
            path: path of executable file
            args: tuple or list of strings

    spawnve(...)
        spawnve(mode, path, args, env)

        Execute the program 'path' in a new process.

            mode: mode of process creation
            path: path of executable file
            args: tuple or list of arguments
            env: dictionary of strings mapping to strings

    startfile(...)
        startfile(filepath [, operation]) - Start a file with its associated
        application.

        When "operation" is not specified or "open", this acts like
        double-clicking the file in Explorer, or giving the file name as an
        argument to the DOS "start" command: the file is opened with whatever
        application (if any) its extension is associated.
        When another "operation" is given, it specifies what should be done with
        the file.  A typical operation is "print".

        startfile returns as soon as the associated application is launched.
        There is no option to wait for the application to close, and no way
        to retrieve the application's exit status.

        The filepath is relative to the current directory.  If you want to use
        an absolute path, make sure the first character is not a slash ("/");
        the underlying Win32 ShellExecute function doesn't work if it is.

    stat(...)
        stat(path) -> stat result

        Perform a stat system call on the given path.

    stat_float_times(...)
        stat_float_times([newval]) -> oldval

        Determine whether os.[lf]stat represents time stamps as float objects.
        If newval is True, future calls to stat() return floats, if it is False,
        future calls return ints.
        If newval is omitted, return the current setting.

    strerror(...)
        strerror(code) -> string

        Translate an error code to a message string.

    system(...)
        system(command) -> exit_status

        Execute the command (a string) in a subshell.

    tempnam(...)
        tempnam([dir[, prefix]]) -> string

        Return a unique name for a temporary file.
        The directory and a prefix may be specified as strings; they may be omitted
        or None if not needed.

    times(...)
        times() -> (utime, stime, cutime, cstime, elapsed_time)

        Return a tuple of floating point numbers indicating process times.

    tmpfile(...)
        tmpfile() -> file object

        Create a temporary file with no directory entries.

    tmpnam(...)
        tmpnam() -> string

        Return a unique name for a temporary file.

    umask(...)
        umask(new_mask) -> old_mask

        Set the current numeric umask and return the previous umask.

    unlink(...)
        unlink(path)

        Remove a file (same as remove(path)).

    urandom(...)
        urandom(n) -> str

        Return n random bytes suitable for cryptographic use.

    utime(...)
        utime(path, (atime, mtime))
        utime(path, None)

        Set the access and modified time of the file to the given values.  If the
        second form is used, set the access and modified times to the current time.

    waitpid(...)
        waitpid(pid, options) -> (pid, status << 8)

        Wait for completion of a given process.  options is ignored on Windows.

    walk(top, topdown=True, onerror=None, followlinks=False)
        Directory tree generator.

        For each directory in the directory tree rooted at top (including top
        itself, but excluding '.' and '..'), yields a 3-tuple

            dirpath, dirnames, filenames

        dirpath is a string, the path to the directory.  dirnames is a list of
        the names of the subdirectories in dirpath (excluding '.' and '..').
        filenames is a list of the names of the non-directory files in dirpath.
        Note that the names in the lists are just names, with no path components.
        To get a full path (which begins with top) to a file or directory in
        dirpath, do os.path.join(dirpath, name).

        If optional arg 'topdown' is true or not specified, the triple for a
        directory is generated before the triples for any of its subdirectories
        (directories are generated top down).  If topdown is false, the triple
        for a directory is generated after the triples for all of its
        subdirectories (directories are generated bottom up).

        When topdown is true, the caller can modify the dirnames list in-place
        (e.g., via del or slice assignment), and walk will only recurse into the
        subdirectories whose names remain in dirnames; this can be used to prune the
        search, or to impose a specific order of visiting.  Modifying dirnames when
        topdown is false is ineffective, since the directories in dirnames have
        already been generated by the time dirnames itself is generated. No matter
        the value of topdown, the list of subdirectories is retrieved before the
        tuples for the directory and its subdirectories are generated.

        By default errors from the os.listdir() call are ignored.  If
        optional arg 'onerror' is specified, it should be a function; it
        will be called with one argument, an os.error instance.  It can
        report the error to continue with the walk, or raise the exception
        to abort the walk.  Note that the filename is available as the
        filename attribute of the exception object.

        By default, os.walk does not follow symbolic links to subdirectories on
        systems that support them.  In order to get this functionality, set the
        optional argument 'followlinks' to true.

        Caution:  if you pass a relative pathname for top, don't change the
        current working directory between resumptions of walk.  walk never
        changes the current directory, and assumes that the client doesn't
        either.

        Example:

        import os
        from os.path import join, getsize
        for root, dirs, files in os.walk('python/Lib/email'):
            print root, "consumes",
            print sum([getsize(join(root, name)) for name in files]),
            print "bytes in", len(files), "non-directory files"
            if 'CVS' in dirs:
                dirs.remove('CVS')  # don't visit CVS directories

    write(...)
        write(fd, string) -> byteswritten

        Write a string to a file descriptor.

DATA
    F_OK = 0
    O_APPEND = 8
    O_BINARY = 32768
    O_CREAT = 256
    O_EXCL = 1024
    O_NOINHERIT = 128
    O_RANDOM = 16
    O_RDONLY = 0
    O_RDWR = 2
    O_SEQUENTIAL = 32
    O_SHORT_LIVED = 4096
    O_TEMPORARY = 64
    O_TEXT = 16384
    O_TRUNC = 512
    O_WRONLY = 1
    P_DETACH = 4
    P_NOWAIT = 1
    P_NOWAITO = 3
    P_OVERLAY = 2
    P_WAIT = 0
    R_OK = 4
    SEEK_CUR = 1
    SEEK_END = 2
    SEEK_SET = 0
    TMP_MAX = 32767
    W_OK = 2
    X_OK = 1
    __all__ = ['altsep', 'curdir', 'pardir', 'sep', 'extsep', 'pathsep', '...
    altsep = '/'
    curdir = '.'
    defpath = r'.;C:\bin'
    devnull = 'nul'
    environ = {'TMP': 'C:\\Users\\dfcrosby\\AppData\\Local\\Te...s\\Public...
    extsep = '.'
    linesep = '\r\n'
    name = 'nt'
    pardir = '..'
    pathsep = ';'
    sep = r'\'


PS K:\github\learningpython> python -m pydoc sys
Help on built-in module sys:

NAME
    sys

FILE
    (built-in)

MODULE DOCS
    http://docs.python.org/library/sys

DESCRIPTION
    This module provides access to some objects used or maintained by the
    interpreter and to functions that interact strongly with the interpreter.

    Dynamic objects:

    argv -- command line arguments; argv[0] is the script pathname if known
    path -- module search path; path[0] is the script directory, else ''
    modules -- dictionary of loaded modules

    displayhook -- called to show results in an interactive session
    excepthook -- called to handle any uncaught exception other than SystemExit
      To customize printing in an interactive session or to install a custom
      top-level exception handler, assign other functions to replace these.

    exitfunc -- if sys.exitfunc exists, this routine is called when Python exits
      Assigning to sys.exitfunc is deprecated; use the atexit module instead.

    stdin -- standard input file object; used by raw_input() and input()
    stdout -- standard output file object; used by the print statement
    stderr -- standard error object; used for error messages
      By assigning other file objects (or objects that behave like files)
      to these, it is possible to redirect all of the interpreter's I/O.

    last_type -- type of last uncaught exception
    last_value -- value of last uncaught exception
    last_traceback -- traceback of last uncaught exception
      These three are only available in an interactive session after a
      traceback has been printed.

    exc_type -- type of exception currently being handled
    exc_value -- value of exception currently being handled
    exc_traceback -- traceback of exception currently being handled
      The function exc_info() should be used instead of these three,
      because it is thread-safe.

    Static objects:

    float_info -- a dict with information about the float inplementation.
    long_info -- a struct sequence with information about the long implementation.
    maxint -- the largest supported integer (the smallest is -maxint-1)
    maxsize -- the largest supported length of containers.
    maxunicode -- the largest supported character
    builtin_module_names -- tuple of module names built into this interpreter
    version -- the version of this interpreter as a string
    version_info -- version information as a named tuple
    hexversion -- version information encoded as a single integer
    copyright -- copyright notice pertaining to this interpreter
    platform -- platform identifier
    executable -- absolute path of the executable binary of the Python interpreter
    prefix -- prefix used to find the Python library
    exec_prefix -- prefix used to find the machine-specific Python library
    float_repr_style -- string indicating the style of repr() output for floats
    dllhandle -- [Windows only] integer handle of the Python DLL
    winver -- [Windows only] version number of the Python DLL
    __stdin__ -- the original stdin; don't touch!
    __stdout__ -- the original stdout; don't touch!
    __stderr__ -- the original stderr; don't touch!
    __displayhook__ -- the original displayhook; don't touch!
    __excepthook__ -- the original excepthook; don't touch!

    Functions:

    displayhook() -- print an object to the screen, and save it in __builtin__._
    excepthook() -- print an exception and its traceback to sys.stderr
    exc_info() -- return thread-safe information about the current exception
    exc_clear() -- clear the exception state for the current thread
    exit() -- exit the interpreter by raising SystemExit
    getdlopenflags() -- returns flags to be used for dlopen() calls
    getprofile() -- get the global profiling function
    getrefcount() -- return the reference count for an object (plus one :-)
    getrecursionlimit() -- return the max recursion depth for the interpreter
    getsizeof() -- return the size of an object in bytes
    gettrace() -- get the global debug tracing function
    setcheckinterval() -- control how often the interpreter checks for events
    setdlopenflags() -- set the flags to be used for dlopen() calls
    setprofile() -- set the global profiling function
    setrecursionlimit() -- set the max recursion depth for the interpreter
    settrace() -- set the global debug tracing function

FUNCTIONS
    __displayhook__ = displayhook(...)
        displayhook(object) -> None

        Print an object to sys.stdout and also save it in __builtin__._

    __excepthook__ = excepthook(...)
        excepthook(exctype, value, traceback) -> None

        Handle an exception by displaying it with a traceback on sys.stderr.

    call_tracing(...)
        call_tracing(func, args) -> object

        Call func(*args), while tracing is enabled.  The tracing state is
        saved, and restored afterwards.  This is intended to be called from
        a debugger from a checkpoint, to recursively debug some other code.

    callstats(...)
        callstats() -> tuple of integers

        Return a tuple of function call statistics, if CALL_PROFILE was defined
        when Python was built.  Otherwise, return None.

        When enabled, this function returns detailed, implementation-specific
        details about the number of function calls executed. The return value is
        a 11-tuple where the entries in the tuple are counts of:
        0. all function calls
        1. calls to PyFunction_Type objects
        2. PyFunction calls that do not create an argument tuple
        3. PyFunction calls that do not create an argument tuple
           and bypass PyEval_EvalCodeEx()
        4. PyMethod calls
        5. PyMethod calls on bound methods
        6. PyType calls
        7. PyCFunction calls
        8. generator calls
        9. All other calls
        10. Number of stack pops performed by call_function()

    displayhook(...)
        displayhook(object) -> None

        Print an object to sys.stdout and also save it in __builtin__._

    exc_clear(...)
        exc_clear() -> None

        Clear global information on the current exception.  Subsequent calls to
        exc_info() will return (None,None,None) until another exception is raised
        in the current thread or the execution stack returns to a frame where
        another exception is being handled.

    exc_info(...)
        exc_info() -> (type, value, traceback)

        Return information about the most recent exception caught by an except
        clause in the current stack frame or in an older stack frame.

    excepthook(...)
        excepthook(exctype, value, traceback) -> None

        Handle an exception by displaying it with a traceback on sys.stderr.

    exit(...)
        exit([status])

        Exit the interpreter by raising SystemExit(status).
        If the status is omitted or None, it defaults to zero (i.e., success).
        If the status is an integer, it will be used as the system exit status.
        If it is another kind of object, it will be printed and the system
        exit status will be one (i.e., failure).

    getcheckinterval(...)
        getcheckinterval() -> current check interval; see setcheckinterval().

    getdefaultencoding(...)
        getdefaultencoding() -> string

        Return the current default string encoding used by the Unicode
        implementation.

    getfilesystemencoding(...)
        getfilesystemencoding() -> string

        Return the encoding used to convert Unicode filenames in
        operating system filenames.

    getprofile(...)
        getprofile()

        Return the profiling function set with sys.setprofile.
        See the profiler chapter in the library manual.

    getrecursionlimit(...)
        getrecursionlimit()

        Return the current value of the recursion limit, the maximum depth
        of the Python interpreter stack.  This limit prevents infinite
        recursion from causing an overflow of the C stack and crashing Python.

    getrefcount(...)
        getrefcount(object) -> integer

        Return the reference count of object.  The count returned is generally
        one higher than you might expect, because it includes the (temporary)
        reference as an argument to getrefcount().

    getsizeof(...)
        getsizeof(object, default) -> int

        Return the size of object in bytes.

    gettrace(...)
        gettrace()

        Return the global debug tracing function set with sys.settrace.
        See the debugger chapter in the library manual.

    getwindowsversion(...)
        getwindowsversion()

        Return information about the running version of Windows as a named tuple.
        The members are named: major, minor, build, platform, service_pack,
        service_pack_major, service_pack_minor, suite_mask, and product_type. For
        backward compatibility, only the first 5 items are available by indexing.
        All elements are numbers, except service_pack which is a string. Platform
        may be 0 for win32s, 1 for Windows 9x/ME, 2 for Windows NT/2000/XP/Vista/7,
        3 for Windows CE. Product_type may be 1 for a workstation, 2 for a domain
        controller, 3 for a server.

    setcheckinterval(...)
        setcheckinterval(n)

        Tell the Python interpreter to check for asynchronous events every
        n instructions.  This also affects how often thread switches occur.

    setprofile(...)
        setprofile(function)

        Set the profiling function.  It will be called on each function call
        and return.  See the profiler chapter in the library manual.

    setrecursionlimit(...)
        setrecursionlimit(n)

        Set the maximum depth of the Python interpreter stack to n.  This
        limit prevents infinite recursion from causing an overflow of the C
        stack and crashing Python.  The highest possible limit is platform-
        dependent.

    settrace(...)
        settrace(function)

        Set the global debug tracing function.  It will be called on each
        function call.  See the debugger chapter in the library manual.

DATA
    __stderr__ = <open file '<stderr>', mode 'w'>
    __stdin__ = <open file '<stdin>', mode 'r'>
    __stdout__ = <open file '<stdout>', mode 'w'>
    api_version = 1013
    argv = [r'C:\Python27\lib\pydoc.py', 'sys']
    builtin_module_names = ('__builtin__', '__main__', '_ast', '_bisect', ...
    byteorder = 'little'
    copyright = 'Copyright (c) 2001-2014 Python Software Foundati...ematis...
    dllhandle = 503316480
    dont_write_bytecode = False
    exc_value = TypeError("<module 'sys' (built-in)> is a built-in module"...
    exec_prefix = r'C:\Python27'
    executable = r'C:\Python27\python.exe'
    flags = sys.flags(debug=0, py3k_warning=0, division_warn...unicode=0, ...
    float_info = sys.float_info(max=1.7976931348623157e+308, max_...epsilo...
    float_repr_style = 'short'
    hexversion = 34015472
    long_info = sys.long_info(bits_per_digit=15, sizeof_digit=2)
    maxint = 2147483647
    maxsize = 2147483647
    maxunicode = 65535
    meta_path = []
    modules = {'UserDict': <module 'UserDict' from 'C:\Python27\lib\UserDi...
    path = ['', r'C:\Windows\system32\python27.zip', r'C:\Python27\DLLs', ...
    path_hooks = [<type 'zipimport.zipimporter'>]
    path_importer_cache = {'': None, r'C:\Python27': None, r'C:\Python27\D...
    platform = 'win32'
    prefix = r'C:\Python27'
    py3kwarning = False
    stderr = <open file '<stderr>', mode 'w'>
    stdin = <open file '<stdin>', mode 'r'>
    stdout = <open file '<stdout>', mode 'w'>
    subversion = ('CPython', '', '')
    version = '2.7.8 (default, Jun 30 2014, 16:03:49) [MSC v.1500 32 bit (...
    version_info = sys.version_info(major=2, minor=7, micro=8, releaseleve...
    warnoptions = []
    winver = '2.7'

